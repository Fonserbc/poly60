<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>LowRezJam19 - Fonserbc</title>
		<style>
		body {
			background-color: #818F81;
		}

		canvas {
			image-rendering: pixelated;
			/*zoom: 700%;*/
			display: block;
		    position: absolute;
		    left: 0;
		    top: 0;
			image-rendering: pixelated;
			image-rendering: crisp-edges;
			image-rendering: -moz-crisp-edges;
			image-rendering: -o-crisp-edges;
			image-rendering: -webkit-optimize-contrast;
			-ms-interpolation-mode: nearest-neighbor;
			z-index: 0;
		}

		#bg-canvas {
			z-index: -1;
		}

		div#holder {
			padding-left: 0;
		    padding-right: 0;
		    margin-left: auto;
		    margin-right: auto;
		    display: block;		    
			position: relative;
			width: 576px;
			height: 576px;
		}

		div#footer {
			margin: 0 auto;
		}
		</style>
	</head>
	<body>
		<div id="holder">
			<canvas id="bg-canvas" width="576" height="576"></canvas>
			<canvas id="canvas" width="576" height="576"></canvas>
		</div>
		<script type="text/javascript">
			window.requestAnimFrame = (function(){
			return  window.requestAnimationFrame       ||
					window.webkitRequestAnimationFrame ||
					window.mozRequestAnimationFrame    ||
					window.oRequestAnimationFrame      ||
					window.msRequestAnimationFrame     || //In case not supported, we define the function
					function(/* function */ callback, /* DOMElement */ element){
						window.setTimeout(callback, 1000 / 60);
					};
			})();
		</script>

		<script src="lib/Tone.js"> </script>
		<script src="AssetManager.js"> </script>

		<script type="text/javascript">
			var SCALE = 9;
			var WIDTH = 64;
			var HEIGHT = 64;
			var TIME_STEPS = 60;
			var CHANNELS = 7;
			var CHANNEL_HEIGHT = 7;
			var MIN_BPM = 120;
			var MAX_BPM = 360;
			var D_BPM = 240;
			assetManager = new AssetManager();
			assetManager.downloadQueue = ["bg.png", "power_off.png", "power_on.png"];

			/*******************/
			/***** Colors ******/
			/*******************/
			var c_beatHighlight = "rgba(0,0,0,0.35)";
			var c_minusPlus = "#abaea3";
			var c_muteButtonOn = "#E82317";
			var c_muteButtonOnSide = "#FF5227";
			var c_muteButtonOff = "#85140D";
			var c_muteButtonOffSide = "#6E2310";
			var c_stopButtonFront = "#535548";
			var c_stopButtonBG = "#191a16";
			var channelColours = [
				{r: 255, g: 51, b: 18}, // red
				{r: 189, g: 20, b: 217}, // purple
				{r: 37, g: 53, b: 240}, // marine blue
				{r: 22, g: 216, b: 217}, // cyan
				{r: 30, g: 250, b: 34}, // green
				{r: 255, g: 161, b: 23}, // orange
				{r: 227, g: 215, b: 16}, // yellow
			];
			var c_bmpLED = {r: 255, g: 10, b: 0};

			function rgb(c) {
				return "rgb("+c.r+","+c.g+","+c.b+")";
			}

			function darken(c, f = 0.5) {
				return {r: Math.floor(c.r * f), g: Math.floor(c.g * f), b: Math.floor(c.b * f)};
			}

			function colorLerp(c1, c2, f) {
				return {r: Math.floor((c1.r + c2.r) * f), g: Math.floor((c1.g + c2.g) * f), b: Math.floor((c1.b + c2.b) * f)};
			}

			function rgba(c, a = 0.5) {
				return "rgba("+c.r+","+c.g+","+c.b+","+a+")";
			}

			/*******************/
			/*** Tonejs init ***/
			/*******************/

			var transport = Tone.Transport;
			var bmp = D_BPM;
			transport.bpm.value = bmp;
			transport.timeSignature = TIME_STEPS;
			transport.loop = true;
			transport.setLoopPoints(0,"1m");
			transport.scheduleRepeat(transportCallback, "4n");

			var channels = [];
			var times = [12,10,6,5,4,3,2];
			var channelNotes = ["D5","A4","D4","B3","E3","G2","C2"];

			for (let i = 0; i < CHANNELS; ++i) {
				let channel = {
					id: i,
					synth: new Tone.Synth().toMaster(),
					colourIt: i,
					timeShift: 0,
					isOn: false,
					get colour () {
						return channelColours[this.colourIt];
					}
				};
				channels.push(channel);
			}

			var lastTransportTime = 0;
			function transportCallback (time)
			{
				transportIt = getCurrentTransportIt();

				for (let i = 0; i < CHANNELS; ++i) {
					if (channels[i].isOn) {
						if (transportIt % times[i] == channels[i].timeShift) {
							channels[i].synth.triggerAttackRelease(channelNotes[channels[i].colourIt], Tone.Time("4n"), time, 0.7);
						}
					}
				}

				lastTransportTime = 0;
			}

			function getCurrentTransportIt() {
				return parseInt(transport.position.split(':')[1]);
			}

			function decreaseBPM() {
				setBPM(Math.max(bmp - 20, MIN_BPM));
			}
			function increaseBPM() {
				setBPM(Math.min(bmp + 20, MAX_BPM));
			}

			function setBPM(newBPM) {
				if (transport.state != "started" || true) {
					transport.bpm.value = newBPM;
				}
				else {
					transport.bpm.rampTo(newBPM, 0.3);
				}
				//console.log("setting BPM at "+newBPM);
				bmp = newBPM;
			}

			/*******************/
			/***** Buttons *****/
			/*******************/

			var buttons = [];
			// OnOff
			var onOffButton = {
				active: true,
				isOn: false,
				onSprite: "power_on.png",
				offSprite: "power_off.png",

				buttonRect: {
					x: 1, y: 58,
					width: 5, height: 5
				},
				onmousedown: function () {
					this.isOn = !this.isOn;

					if (this.isOn) {
						turnMachineOn();
					}
					else {
						turnMachineOff();
					}
					console.log("Turned machine "+(this.isOn? "ON" : "OFF"));
				},
				draw: function(ctx) {
					ctx.drawImageScaled(assetManager.getAsset(this.isOn? this.onSprite : this.offSprite), this.buttonRect.x, this.buttonRect.y, this.buttonRect.width, this.buttonRect.height);
				}
			};
			buttons.push(onOffButton); // 0


			// stop button
			var stopButton = {
				active: false,
				pressed: false,
				justPressed: false,

				buttonRect: {
					x: 54, y: 58,
					width: 4, height: 5
				},
				onmousedown: function () {
					if (!this.pressed) {
						this.pressed = true;
						transport.stop();
						this.justPressed = true;
					}
				},
				onmouseup: function () {
					if (this.pressed && !this.justPressed) {
						this.pressed = false;
						transport.start();
					}
					this.justPressed = false;
				},
				draw: function(ctx) {
					if (this.active) {
						if (this.pressed) {
							ctx.fillStyle = c_stopButtonFront;	
							ctx.fillRectScaled(this.buttonRect.x, this.buttonRect.y, 4, 4);
							
							let t = Math.floor(Time.time * 2) % 2;
							if (t == 0) ctx.fillStyle = rgb(c_bmpLED);
							else ctx.fillStyle = rgb(darken(c_bmpLED, 0.2));

							ctx.fillRectScaled(this.buttonRect.x + 1, this.buttonRect.y + 1, 2, 2);
						}
						else {
							ctx.fillStyle = c_stopButtonBG;
							ctx.fillRectScaled(this.buttonRect.x, this.buttonRect.y, 4, 1);

							ctx.fillStyle = c_stopButtonFront;	
							ctx.fillRectScaled(this.buttonRect.x, this.buttonRect.y + 1, 4, 4);

							ctx.fillStyle = rgb(darken(c_bmpLED, 0.2));
							ctx.fillRectScaled(this.buttonRect.x + 1, this.buttonRect.y + 2, 2, 2);

							let t = transportIt % 4;
							let aux = {x: 0, y:0};

							if (t == 1 || t == 2) aux.x = 1;
							if (t == 2 || t == 3) aux.y = 1;
							ctx.fillStyle = rgb(c_bmpLED);
							ctx.fillRectScaled(this.buttonRect.x + 1 + aux.x, this.buttonRect.y + 2 + aux.y, 1, 1);
						}
					}
				}
			};
			buttons.push(stopButton);
			// -
			var minusButton = {
				pressed: false,
				active: false,

				buttonRect: {
					x: 49, y: 60,
					width: 3, height: 2
				},
				onmousedown: function () {
					this.pressed = true;
					decreaseBPM();
				},
				onmouseup: function() {
					this.pressed = false;
				},
				draw: function(ctx) {
					if(this.active) {
						ctx.fillStyle = c_minusPlus;
						let aux = this.pressed? 0 : 1;
						ctx.fillRectScaled(this.buttonRect.x, this.buttonRect.y + aux, this.buttonRect.width, 1);
					}
				}
			}
			buttons.push(minusButton);
			// +
			var plusButton = {
				pressed: false,
				active: false,

				buttonRect: {
					x: 60, y: 59,
					width: 3, height: 3
				},
				onmousedown: function () {
					this.pressed = true;
					increaseBPM();
				},
				onmouseup: function() {
					this.pressed = false;
				},
				draw: function(ctx) {
					if(this.active) {
						ctx.fillStyle = c_minusPlus;
						let aux = this.pressed? 0 : 1;
						ctx.fillRectScaled(this.buttonRect.x + 1, this.buttonRect.y + aux, 1, 3);
						ctx.fillRectScaled(this.buttonRect.x, this.buttonRect.y + aux + 1, this.buttonRect.width, 1);
					}
				}
			}
			buttons.push(plusButton);

			// Channel buttons
			for (let i = 0; i < CHANNELS; ++i) {
				let muteButton = {
					pressed: false,
					active: false,
					id: i,

					buttonRect: {
						x: 1, y: 10 + i * CHANNEL_HEIGHT,
						width: 1, height: 3
					},
					onmousedown: function () {
						this.pressed = true;
					},
					onmouseup: function() {
						this.pressed = false;
						muteChannelPressed(i);
					},
					draw: function(ctx) {
						if(this.active) {
							let isOn = channels[this.id].isOn;
							let aux = this.pressed? 1 : 0;
							ctx.fillStyle = isOn? c_muteButtonOn : c_muteButtonOff;
							ctx.fillRectScaled(this.buttonRect.x, this.buttonRect.y + aux, 1, 2);
							if (!this.pressed) {
								ctx.fillStyle = isOn? c_muteButtonOnSide : c_muteButtonOffSide;
								ctx.fillRectScaled(this.buttonRect.x, this.buttonRect.y + 2, 1, 1);
							}
						}
					}
				}
				buttons.push(muteButton);

				let switchButton = {
					pressed: false,
					active: false,
					id: i,

					buttonRect: {
						x: 1, y: 7 + i * CHANNEL_HEIGHT,
						width: 1, height: 2
					},
					onmousedown: function () {
						this.pressed = true;
					},
					onmouseup: function() {
						this.pressed = false;
						changeChannelPressed(i);
					},
					draw: function(ctx) {
						if(this.active) {
							let aux = this.pressed? 1 : 0;
							let colour = channels[this.id].colour;
							ctx.fillStyle = rgb(colour);
							ctx.fillRectScaled(this.buttonRect.x, this.buttonRect.y + aux, 1, 1);
							if (!this.pressed) {
								ctx.fillStyle = rgb(darken(colour));
								ctx.fillRectScaled(this.buttonRect.x, this.buttonRect.y + 1, 1, 1);
							}
						}
					}
				}
				buttons.push(switchButton);

				let touchInterface = {
					active: false,
					mouseIsOver: false,
					id: i,
					buttonRect: {
						x: 3, y: 7 + i * CHANNEL_HEIGHT,
						width: 60, height: CHANNEL_HEIGHT
					},
					onmousedown: function (pos) {
						let p = pos.x - this.buttonRect.x;
						p = p % times[this.id];

						if (channels[this.id].isOn) {
							if (channels[this.id].timeShift == p) {
								channels[this.id].isOn = false;
							}
							else {
								channels[this.id].timeShift = p;
							}
						}
						else {
							channels[this.id].isOn = true;
							channels[this.id].timeShift = p;
						}
					},
					onmouseenter: function () {
						this.mouseIsOver = true;
					},
					onmouseexit: function () {
						this.mouseIsOver = false;
					},
					draw: function(ctx) {
						if (this.mouseIsOver) {
							let p = lastMousePosition.x - this.buttonRect.x;
							p = p % times[this.id];

							if (p == channels[this.id].timeShift && channels[this.id].isOn) {
								ctx.fillStyle = rgb(channels[this.id].colour);
							}
							else {
								ctx.fillStyle = rgba(channels[this.id].colour, 0.35);
							}

							for (let j = p; j < TIME_STEPS; j += times[this.id]) {
								ctx.fillRectScaled(3 + j, 7 + this.id * CHANNEL_HEIGHT, 1, CHANNEL_HEIGHT);
							}
						}
					}
				}
				buttons.push(touchInterface);
			}

			function isMachineOn() {
				return onOffButton.isOn;
			}

			function turnMachineOn() {
				transport.start();
				for (let i = 1; i < buttons.length; ++i) {
					buttons[i].active = true;
				}
				stopButton.pressed = false;
			}

			function turnMachineOff() {
				transport.stop();
				for (let i = 1; i < buttons.length; ++i) {
					buttons[i].active = false;
				}

				setBPM(D_BPM);
			}

			function muteChannelPressed(channelIt) {
				if (!channels[channelIt].isOn) {
					channels[channelIt].isOn = true;
				}
				else {
					let shift = channels[channelIt].timeShift;

					shift ++;
					if (shift >= times[channelIt]) {
						channels[channelIt].timeShift = 0;
						channels[channelIt].isOn = false;
					}
					else {
						channels[channelIt].timeShift = shift;
					}
				}

				return channels[channelIt].isOn;
			}

			function changeChannelPressed(channelIt) {
				let it = channels[channelIt].colourIt + 1;
				if (it >= CHANNELS) {
					it = 0;
				}
				channels[channelIt].colourIt = it;
			}

			var canvas = document.getElementById("canvas");
			var ctx = canvas.getContext("2d");
			var bgCanvas = document.getElementById("bg-canvas");
			var bgCtx = bgCanvas.getContext("2d");
			ctx.imageSmoothingEnabled = false;
			ctx.webkitImageSmoothingEnabled  = false;
			bgCtx.imageSmoothingEnabled = false;
			bgCtx.webkitImageSmoothingEnabled  = false;

			ctx.fillRectScaled = function (x, y, w, h) {
				ctx.fillRect(x * SCALE, y * SCALE, w * SCALE, h * SCALE);
			}

			ctx.drawImageScaled = function (image, x, y, w, h) {
				ctx.drawImage(image, x * SCALE, y * SCALE, w * SCALE, h * SCALE);
			}
			 
			/*******************/
			/****** Input ******/
			/*******************/

			function getMousePos(e) {
				var rect = canvas.getBoundingClientRect();
				return {
				  x: Math.floor((e.clientX - rect.left)/SCALE),
				  y: Math.floor((e.clientY - rect.top)/SCALE)
				};
			}

			var pressedButton = null;
			function onmousedown (e) {
				var pos = getMousePos(e);
				var button = getButtonUnder(pos);

				if (button && button.active && button.onmousedown) {
					button.onmousedown(pos);
					pressedButton = button;
				}
			}

			var overButton = null;
			var lastMousePosition = {x:0, y:0};
			function onmousemove (e) {
				var pos = getMousePos(e);
			
				var button = getButtonUnder(pos);

				if (button && button.active) {
					document.body.style.cursor = "pointer";

					if (overButton != button) {
						if (overButton) {
							if (overButton.onmouseexit)
								overButton.onmouseexit();
							if (pressedButton) {
								if (pressedButton.onmouseup)
									pressedButton.onmouseup();
								pressedButton = null;
							}
						}

						if (button.onmouseenter) {
							button.onmouseenter();
						}
					}

					if (button.onmousemove) {
						button.onmousemove(pos);
					}
				}
				else {
					document.body.style.cursor = "default";

					if (overButton && overButton.onmouseexit) {
						overButton.onmouseexit();
					}

					if (pressedButton && pressedButton.onmouseup) {
						pressedButton.onmouseup();
					}
					pressedButton = null;
				}

				overButton = button;

				lastMousePosition = pos;
			}

			function onmouseup (e) {
				var pos = getMousePos(e);

				if (pressedButton && pressedButton.onmouseup) {
					pressedButton.onmouseup();
				}
				pressedButton = null;
			}

			canvas.addEventListener("mousedown", onmousedown);
			canvas.addEventListener("mousemove", onmousemove);
			document.addEventListener("mouseup", onmouseup);
			
			//document.onkeydown = keydown;
			//document.onkeyup = keyup;

			/*******************/
			/****** Logic ******/
			/*******************/
			function collides(rect, pos) {
				return pos.x >= rect.x && pos.y >= rect.y && pos.x < rect.x + rect.width && pos.y < rect.y + rect.height;
			}

			function getButtonUnder(pos) {
				for (let i = 0; i < buttons.length; ++i) {
					if (collides(buttons[i].buttonRect, pos)) {
						return buttons[i];
					}
				}

				return null;
			}
			
			var transportIt = 0;
			var lastTick = 0;
			var maxTick = 1/20;
			var Time = {
				time : 0,
				deltaTime: 0
			};
			function update(tick)
			{
				var deltaTime = Math.min((tick - lastTick)/1000, maxTick);
				lastTick = tick;

				Time.deltaTime = deltaTime;
				Time.time += deltaTime;

				transportIt = getCurrentTransportIt();

				lastTransportTime += deltaTime;
			}

			function draw() {
				ctx.fillStyle = "#FFF";
				ctx.clearRect(0,0,WIDTH*SCALE,HEIGHT*SCALE);
				
				if (transport.state != "stopped") {
					ctx.fillStyle = c_beatHighlight;
					ctx.fillRectScaled((3 + transportIt), 7, 1, 7 * CHANNELS);
				}

				if (isMachineOn()) {
					for (let i = 0; i < CHANNELS; ++i) {
						if (channels[i].isOn) {
							for (let j = channels[i].timeShift; j < TIME_STEPS; j += times[i]) {
								if (transportIt == j) {
									ctx.fillStyle = rgb(channelColours[channels[i].colourIt]);
								}
								else {
									ctx.fillStyle = rgb(darken(channelColours[channels[i].colourIt], 0.7));
								}
								ctx.fillRectScaled(3 + j, 7 + i * CHANNEL_HEIGHT, 1, CHANNEL_HEIGHT);
							}
						}
					}
				}

				buttons.forEach(function (b) {
					b.draw(ctx);
				});
			}

			function loop (tick) {
				update(tick);
				draw();

				window.requestAnimFrame(loop);
			}

			ctx.fillStyle = "#000";
			ctx.clearRect(0,0,WIDTH*SCALE,HEIGHT*SCALE);
			bgCtx.fillStyle = "#000";
			bgCtx.clearRect(0,0,WIDTH*SCALE,HEIGHT*SCALE);

			assetManager.downloadAll(function() {
				bgCtx.drawImage(assetManager.getAsset("bg.png"), 0, 0, WIDTH*SCALE, HEIGHT*SCALE);
				
				window.requestAnimFrame(loop);
			});
		</script>
	</body>	
</html>