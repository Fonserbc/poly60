<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>LowRezJam19 - Fonserbc</title>
		<style>
		canvas {
			image-rendering: pixelated;
			/*zoom: 700%;*/
			display: block;
		    position: absolute;
		    left: 0;
		    top: 0;
			image-rendering: pixelated;
			image-rendering: crisp-edges;
			image-rendering: -moz-crisp-edges;
			image-rendering: -o-crisp-edges;
			image-rendering: -webkit-optimize-contrast;
			-ms-interpolation-mode: nearest-neighbor;
			z-index: 0;
		}

		#bg-canvas {
			z-index: -1;
		}

		div#holder {
			padding-left: 0;
		    padding-right: 0;
		    margin-left: auto;
		    margin-right: auto;
		    display: block;		    
			position: relative;
			width: 576px;
			height: 576px;
		}

		div#footer {
			margin: 0 auto;
		}
		</style>
	</head>
	<body>
		<div id="holder">
			<canvas id="bg-canvas" width="576" height="576"></canvas>
			<canvas id="canvas" width="576" height="576"></canvas>
		</div>
		<script type="text/javascript">
			window.requestAnimFrame = (function(){
			return  window.requestAnimationFrame       ||
					window.webkitRequestAnimationFrame ||
					window.mozRequestAnimationFrame    ||
					window.oRequestAnimationFrame      ||
					window.msRequestAnimationFrame     || //In case not supported, we define the function
					function(/* function */ callback, /* DOMElement */ element){
						window.setTimeout(callback, 1000 / 60);
					};
			})();
		</script>

		<script src="lib/Tone.js"> </script>
		<script src="AssetManager.js"> </script>

		<script type="text/javascript">
			var SCALE = 9;
			var WIDTH = 64;
			var HEIGHT = 64;
			var TIME_STEPS = 60;
			var CHANNELS = 7;
			var CHANNEL_HEIGHT = 7;
			var MIN_BPM = 120;
			var MAX_BPM = 360;
			var D_BPM = 240;
			assetManager = new AssetManager();
			assetManager.downloadQueue = ["bg.png", "power_off.png", "power_on.png"];

			/*******************/
			/***** Colors ******/
			/*******************/
			var c_beatHighlight = "rgba(255,255,255,0.3)";
			var c_minusPlus = "#abaea3";
			var c_muteButtonOn = "#E82317";
			var c_muteButtonOnSide = "#FF5227";
			var c_muteButtonOff = "#85140D";
			var c_muteButtonOffSide = "#6E2310";
			var channelColours = [
				{r: 255, g: 51, b: 18}, // red
				{r: 189, g: 20, b: 217}, // purple
				{r: 37, g: 53, b: 240}, // marine blue
				{r: 22, g: 216, b: 217}, // cyan
				{r: 30, g: 250, b: 34}, // green
				{r: 255, g: 161, b: 23}, // orange
				{r: 227, g: 215, b: 16}, // yellow
			];

			function rgb(c) {
				return "rgb("+c.r+","+c.g+","+c.b+")";
			}

			function darken(c) {
				return {r: Math.floor(c.r * 0.5), g: Math.floor(c.g * 0.5), b: Math.floor(c.b * 0.5)};
			}

			/*******************/
			/*** Tonejs init ***/
			/*******************/

			var transport = Tone.Transport;
			var bmp = D_BPM;
			transport.bpm.value = bmp;
			transport.timeSignature = TIME_STEPS;
			transport.loop = true;
			transport.setLoopPoints(0,"1m");
			transport.scheduleRepeat(transportCallback, "4n");

			var channels = [];
			var times = [12,10,6,5,4,3,2];
			var channelNotes = ["C2", "G2", "D3", "A3", "E4", "B5", "F5" ];

			for (let i = 0; i < CHANNELS; ++i) {
				let channel = {
					id: i,
					synth: new Tone.Synth().toMaster(),
					colourIt: i,
					timeShift: 0,
					isOn: false
				};
				channels.push(channel);
			}

			function transportCallback (time)
			{
				transportIt = getCurrentTransportIt();

				for (let i = 0; i < CHANNELS; ++i) {
					if (channels[i].isOn) {
						if (transportIt % times[i] == channels[i].timeShift) {
							channels[i].synth.triggerAttackRelease(channelNotes[channels[i].colourIt], "4n", time, 0.7);
						}
					}
				}
			}

			function getCurrentTransportIt() {
				return parseInt(transport.position.split(':')[1]);
			}

			function decreaseBPM() {
				setBPM(Math.max(bmp - 20, MIN_BPM));
			}
			function increaseBPM() {
				setBPM(Math.min(bmp + 20, MAX_BPM));
			}

			function setBPM(newBPM) {
				if (transport.state != "started" || true) {
					transport.bpm.value = newBPM;
				}
				else {
					transport.bpm.rampTo(newBPM, 0.3);
				}
				console.log("setting BPM at "+newBPM);
				bmp = newBPM;
			}

			/*******************/
			/***** Buttons *****/
			/*******************/

			var buttons = [];
			var onOffButton = {
				active: true,
				isOn: false,
				onSprite: "power_on.png",
				offSprite: "power_off.png",

				buttonRect: {
					x: 1, y: 58,
					width: 5, height: 5
				},
				onmousedown: function () {
					this.isOn = !this.isOn;

					if (this.isOn) {
						turnMachineOn();
					}
					else {
						turnMachineOff();
					}
					// TODO Turn off/on music
					console.log("onOffButton pressed, now is "+this.isOn);
				},
				draw: function(ctx) {
					ctx.drawImageScaled(assetManager.getAsset(this.isOn? this.onSprite : this.offSprite), this.buttonRect.x, this.buttonRect.y, this.buttonRect.width, this.buttonRect.height);
				}
			}
			buttons.push(onOffButton); // 0

			// -
			var minusButton = {
				pressed: false,
				active: false,

				buttonRect: {
					x: 49, y: 60,
					width: 3, height: 2
				},
				onmousedown: function () {
					this.pressed = true;
					decreaseBPM();
				},
				onmouseup: function() {
					this.pressed = false;
				},
				draw: function(ctx) {
					if(this.active) {
						ctx.fillStyle = c_minusPlus;
						let aux = this.pressed? 0 : 1;
						ctx.fillRectScaled(this.buttonRect.x, this.buttonRect.y + aux, this.buttonRect.width, 1);
					}
				}
			}
			buttons.push(minusButton);
			// +
			var plusButton = {
				pressed: false,
				active: false,

				buttonRect: {
					x: 60, y: 59,
					width: 3, height: 3
				},
				onmousedown: function () {
					this.pressed = true;
					increaseBPM();
				},
				onmouseup: function() {
					this.pressed = false;
				},
				draw: function(ctx) {
					if(this.active) {
						ctx.fillStyle = c_minusPlus;
						let aux = this.pressed? 0 : 1;
						ctx.fillRectScaled(this.buttonRect.x + 1, this.buttonRect.y + aux, 1, 3);
						ctx.fillRectScaled(this.buttonRect.x, this.buttonRect.y + aux + 1, this.buttonRect.width, 1);
					}
				}
			}
			buttons.push(plusButton);

			// Channel buttons
			for (let i = 0; i < CHANNELS; ++i) {
				let muteButton = {
					pressed: false,
					active: false,
					isOn: false,
					id: i,

					buttonRect: {
						x: 1, y: 10 + i * CHANNEL_HEIGHT,
						width: 1, height: 3
					},
					onmousedown: function () {
						this.pressed = true;
					},
					onmouseup: function() {
						this.pressed = false;
						this.isOn = muteChannelPressed(i);
					},
					draw: function(ctx) {
						if(this.active) {
							let aux = this.pressed? 1 : 0;
							ctx.fillStyle = this.isOn? c_muteButtonOn : c_muteButtonOff;
							ctx.fillRectScaled(this.buttonRect.x, this.buttonRect.y + aux, 1, 2);
							if (!this.pressed) {
								ctx.fillStyle = this.isOn? c_muteButtonOnSide : c_muteButtonOffSide;
								ctx.fillRectScaled(this.buttonRect.x, this.buttonRect.y + 2, 1, 1);
							}
						}
					}
				}
				buttons.push(muteButton);

				let switchButton = {
					pressed: false,
					active: false,
					id: i,
					colour: channelColours[i],

					buttonRect: {
						x: 1, y: 7 + i * CHANNEL_HEIGHT,
						width: 1, height: 2
					},
					onmousedown: function () {
						this.pressed = true;
					},
					onmouseup: function() {
						this.pressed = false;
						this.colour = changeChannelPressed(i);
					},
					draw: function(ctx) {
						if(this.active) {
							let aux = this.pressed? 1 : 0;
							ctx.fillStyle = rgb(this.colour);
							ctx.fillRectScaled(this.buttonRect.x, this.buttonRect.y + aux, 1, 1);
							if (!this.pressed) {
								ctx.fillStyle = rgb(darken(this.colour));
								ctx.fillRectScaled(this.buttonRect.x, this.buttonRect.y + 1, 1, 1);
							}
						}
					}
				}
				buttons.push(switchButton);
			}

			function isMachineOn() {
				return onOffButton.isOn;
			}

			function turnMachineOn() {
				transport.start();
				for (let i = 1; i < buttons.length; ++i) {
					buttons[i].active = true;
				}
			}

			function turnMachineOff() {
				transport.stop();
				for (let i = 1; i < buttons.length; ++i) {
					buttons[i].active = false;
				}

				setBPM(D_BPM);
			}

			function muteChannelPressed(channelIt) {
				if (!channels[channelIt].isOn) {
					channels[channelIt].isOn = true;
				}
				else {
					let shift = channels[channelIt].timeShift;

					shift ++;
					if (shift >= times[channelIt]) {
						channels[channelIt].timeShift = 0;
						channels[channelIt].isOn = false;
					}
					else {
						channels[channelIt].timeShift = shift;
					}
				}

				return channels[channelIt].isOn;
			}

			function changeChannelPressed(channelIt) {
				let it = channels[channelIt].colourIt + 1;
				if (it >= CHANNELS) {
					it = 0;
				}
				channels[channelIt].colourIt = it;

				return channelColours[it];
			}

			var canvas = document.getElementById("canvas");
			var ctx = canvas.getContext("2d");
			var bgCanvas = document.getElementById("bg-canvas");
			var bgCtx = bgCanvas.getContext("2d");
			ctx.imageSmoothingEnabled = false;
			ctx.webkitImageSmoothingEnabled  = false;
			bgCtx.imageSmoothingEnabled = false;
			bgCtx.webkitImageSmoothingEnabled  = false;

			ctx.fillRectScaled = function (x, y, w, h) {
				ctx.fillRect(x * SCALE, y * SCALE, w * SCALE, h * SCALE);
			}

			ctx.drawImageScaled = function (image, x, y, w, h) {
				ctx.drawImage(image, x * SCALE, y * SCALE, w * SCALE, h * SCALE);
			}
			 
			/*******************/
			/****** Input ******/
			/*******************/

			function getMousePos(e) {
				var rect = canvas.getBoundingClientRect();
				return {
				  x: Math.floor((e.clientX - rect.left)/SCALE),
				  y: Math.floor((e.clientY - rect.top)/SCALE)
				};
			}

			var pressedButton = null;
			function onmousedown (e) {
				var pos = getMousePos(e);
				var button = getButtonUnder(pos);

				if (button && button.active && button.onmousedown) {
					button.onmousedown();
					pressedButton = button;
				}
			}

			function onmousemove (e) {
				var pos = getMousePos(e);
			
				var button = getButtonUnder(pos);

				if (button && button.active) {
					document.body.style.cursor = "pointer";

					if (button.onmousemove) {
						button.onmousemove(pos);
					}

					if (pressedButton != null && pressedButton != button) {
						if (pressedButton.onmouseup) {
							pressedButton.onmouseup();
							pressedButton = null;
						}
					}
				}
				else {
					document.body.style.cursor = "default";

					if (pressedButton != null) {
						if (pressedButton.onmouseup) {
							pressedButton.onmouseup();
							pressedButton = null;
						}
					}
				}
			}

			function onmouseup (e) {
				var pos = getMousePos(e);

				if (pressedButton && pressedButton.onmouseup) {
					pressedButton.onmouseup();
				}
				pressedButton = null;
			}

			canvas.addEventListener("mousedown", onmousedown);
			canvas.addEventListener("mousemove", onmousemove);
			document.addEventListener("mouseup", onmouseup);
			
			//document.onkeydown = keydown;
			//document.onkeyup = keyup;

			/*******************/
			/****** Logic ******/
			/*******************/
			function collides(rect, pos) {
				return pos.x >= rect.x && pos.y >= rect.y && pos.x < rect.x + rect.width && pos.y < rect.y + rect.height;
			}

			function getButtonUnder(pos) {
				for (let i = 0; i < buttons.length; ++i) {
					if (collides(buttons[i].buttonRect, pos)) {
						return buttons[i];
					}
				}

				return null;
			}
			
			var transportIt = 0;
			function update() {
				transportIt = getCurrentTransportIt();
			}

			function draw() {
				ctx.fillStyle = "#FFF";
				ctx.clearRect(0,0,WIDTH*SCALE,HEIGHT*SCALE);
				
				buttons.forEach(function (b) {
					b.draw(ctx);
				});

				if (transport.state != "stopped") {
					ctx.fillStyle = c_beatHighlight;
					ctx.fillRectScaled((3 + transportIt), 7, 1, 7 * CHANNELS);
				}

				if (isMachineOn()) {
					for (let i = 0; i < CHANNELS; ++i) {
						if (channels[i].isOn) {
							for (let j = channels[i].timeShift; j < TIME_STEPS; j += times[i]) {
								ctx.fillStyle = rgb(channelColours[channels[i].colourIt]);
								ctx.fillRectScaled(3 + j, 7 + i * CHANNEL_HEIGHT, 1, CHANNEL_HEIGHT);
							}
						}
					}
				}
			}

			function loop () {
				update();
				draw();

				window.requestAnimFrame(loop);
			}

			ctx.fillStyle = "#000";
			ctx.clearRect(0,0,WIDTH*SCALE,HEIGHT*SCALE);
			bgCtx.fillStyle = "#000";
			bgCtx.clearRect(0,0,WIDTH*SCALE,HEIGHT*SCALE);

			assetManager.downloadAll(function() {
				bgCtx.drawImage(assetManager.getAsset("bg.png"), 0, 0, WIDTH*SCALE, HEIGHT*SCALE);
				
				window.requestAnimFrame(loop);
			});
		</script>
	</body>	
</html>